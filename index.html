<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Algorithm Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --accent: #4ecdc4;
            --warning: #ff6b6b;
            --success: #6bcf7f;
            --info: #ffd93d;
            --dark: #1a1a2e;
            --darker: #16213e;
            --light: #e94057;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, var(--dark) 0%, var(--darker) 50%, #0f3460 100%);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: clamp(2rem, 4vw, 3.5rem);
            background: linear-gradient(45deg, var(--light), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 800;
            letter-spacing: -0.02em;
        }

        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 8px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .tab {
            padding: 12px 24px;
            margin: 0 4px;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            border-radius: 12px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            font-size: 0.95rem;
            position: relative;
            overflow: hidden;
        }

        .tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            opacity: 0;
            transition: opacity 0.4s ease;
            border-radius: 12px;
            z-index: -1;
        }

        .tab.active {
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        }

        .tab.active::before {
            opacity: 1;
        }

        .tab:hover:not(.active) {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            transform: translateY(-1px);
        }

        .tab-content {
            display: none;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            color: white;
            font-size: 0.9rem;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        button.danger {
            background: linear-gradient(45deg, var(--warning), #e55353);
        }

        button.success {
            background: linear-gradient(45deg, var(--success), #5cb85c);
        }

        select {
            padding: 12px 16px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-weight: 600;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        select:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
            border-color: var(--accent);
        }

        select option {
            background: var(--darker);
            color: white;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(255, 255, 255, 0.08);
            padding: 8px 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        input[type="range"] {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
        }

        #canvas, #graphCanvas {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            background: rgba(0, 0, 0, 0.3);
            display: block;
            margin: 0 auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .info-panel {
            margin-top: 25px;
            background: rgba(255, 255, 255, 0.08);
            padding: 25px;
            border-radius: 16px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            text-align: center;
        }

        .stat {
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.05);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-label {
            font-size: 0.85rem;
            opacity: 0.8;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--accent);
        }

        .grid-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 25px;
        }

        .grid {
            display: grid;
            gap: 1px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 12px;
        }

        .cell {
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 2px;
        }

        .cell:hover {
            transform: scale(1.1);
        }

        .cell.wall {
            background: #2a2a2a;
            box-shadow: inset 0 0 8px rgba(0,0,0,0.5);
        }

        .cell.start {
            background: var(--accent);
            box-shadow: 0 0 12px var(--accent);
        }

        .cell.end {
            background: var(--warning);
            box-shadow: 0 0 12px var(--warning);
        }

        .cell.visited {
            background: var(--info);
            box-shadow: 0 0 8px var(--info);
        }

        .cell.path {
            background: var(--success);
            box-shadow: 0 0 10px var(--success);
            animation: pulse 1s ease-in-out;
        }
        .cell.weighted {
            background: #ffa500;
            opacity: 0.7;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }

        .algorithm-info {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border-left: 4px solid var(--accent);
        }

        .algorithm-info h3 {
            color: var(--accent);
            margin-bottom: 8px;
            font-size: 1.1rem;
        }

        .algorithm-info p {
            opacity: 0.9;
            line-height: 1.5;
            font-size: 0.9rem;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, var(--accent), var(--primary));
            width: 0%;
            transition: width 0.3s ease;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .sound-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            backdrop-filter: blur(20px);
            transition: all 0.3s ease;
        }

        .sound-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 2rem;
                margin-bottom: 20px;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }

            .tabs {
                flex-direction: column;
                gap: 4px;
            }

            .tab {
                margin: 0;
            }

            #canvas, #graphCanvas {
                width: 100%;
                height: auto;
            }

            .stats {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
            }

            .sound-toggle {
                position: static;
                align-self: flex-end;
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <button class="sound-toggle" onclick="toggleSound()" title="Toggle Sound">🔊</button>

    <div class="container">
        <h1>Algorithm Visualizer Pro</h1>

        <div class="tabs">
            <button class="tab active" onclick="showTab('sorting')">Sorting Algorithms</button>
            <button class="tab" onclick="showTab('pathfinding')">Pathfinding</button>
            <button class="tab" onclick="showTab('graph')">Graph Traversal</button>
            <button class="tab" onclick="showTab('tree')">Binary Trees</button>
        </div>

        <!-- Sorting Tab -->
        <div id="sorting" class="tab-content active">
            <div class="algorithm-info">
                <h3 id="sortingTitle">Bubble Sort</h3>
                <p id="sortingDescription">A simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order.</p>
            </div>

            <div class="controls">
                <select id="sortAlgorithm" onchange="updateSortingInfo()">
                    <option value="bubble">Bubble Sort</option>
                    <option value="selection">Selection Sort</option>
                    <option value="insertion">Insertion Sort</option>
                    <option value="merge">Merge Sort</option>
                    <option value="quick">Quick Sort</option>
                    <option value="heap">Heap Sort</option>
                    <option value="radix">Radix Sort</option>
                    <option value="shell">Shell Sort</option>
                </select>
                <button onclick="generateArray()">Generate Array</button>
                <button id="sortBtn" onclick="startSort()" class="success">Start Sorting</button>
                <button onclick="stopSort()" class="danger">Stop</button>
                <div class="slider-container">
                    <label>Speed:</label>
                    <input type="range" id="speedSlider" min="1" max="100" value="50">
                    <span id="speedValue">50ms</span>
                </div>
                <div class="slider-container">
                    <label>Size:</label>
                    <input type="range" id="sizeSlider" min="20" max="300" value="100">
                    <span id="sizeValue">100</span>
                </div>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="sortProgress"></div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4ecdc4;"></div>
                    <span>Default</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffd93d;"></div>
                    <span>Comparing</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b6b;"></div>
                    <span>Swapping</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #6bcf7f;"></div>
                    <span>Sorted</span>
                </div>
            </div>

            <canvas id="canvas" width="1200" height="450"></canvas>

            <div class="info-panel">
                <div class="stats">
                    <div class="stat">
                        <span class="stat-label">Comparisons</span>
                        <span class="stat-value" id="comparisons">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Swaps</span>
                        <span class="stat-value" id="swaps">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Time Complexity</span>
                        <span class="stat-value" id="timeComplexity">O(n²)</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Space Complexity</span>
                        <span class="stat-value" id="spaceComplexity">O(1)</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Stability</span>
                        <span class="stat-value" id="stability">Stable</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Elapsed Time</span>
                        <span class="stat-value" id="elapsedTime">0ms</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Pathfinding Tab -->
        <div id="pathfinding" class="tab-content">
            <div class="algorithm-info">
                <h3 id="pathTitle">A* Search</h3>
                <p id="pathDescription">An informed search algorithm that uses heuristics to find the optimal path between start and end nodes efficiently.</p>
            </div>

            <div class="controls">
                <select id="pathAlgorithm" onchange="updatePathInfo()">
                    <option value="astar">A* Search</option>
                    <option value="dijkstra">Dijkstra's Algorithm</option>
                    <option value="bfs">Breadth-First Search</option>
                    <option value="dfs">Depth-First Search</option>
                    <option value="greedy">Greedy Best-First</option>
                    <option value="bidirectional">Bidirectional Search</option>
                </select>
                <button onclick="generateMaze()">Generate Maze</button>
                <button onclick="addRandomWalls()">Random Walls</button>
                <button onclick="clearPath()">Clear Path</button>
                <button id="pathBtn" onclick="startPathfinding()" class="success">Find Path</button>
                <button onclick="clearGrid()" class="danger">Clear Grid</button>
                <div class="slider-container">
                    <label>Speed:</label>
                    <input type="range" id="pathSpeedSlider" min="1" max="100" value="30">
                    <span id="pathSpeedValue">30ms</span>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #4ecdc4;"></div>
                    <span>Start</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b6b;"></div>
                    <span>End</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #2a2a2a;"></div>
                    <span>Wall</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffd93d;"></div>
                    <span>Visited</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #6bcf7f;"></div>
                    <span>Path</span>
                </div>
            </div>

            <div class="grid-container">
                <div id="pathGrid" class="grid"></div>
                <p style="opacity: 0.8; text-align: center;">Click to add walls • Drag start/end points • Right-click for weights</p>
            </div>
        </div>

        <!-- Graph Traversal Tab -->
        <div id="graph" class="tab-content">
            <div class="algorithm-info">
                <h3 id="graphTitle">BFS Traversal</h3>
                <p id="graphDescription">Breadth-First Search explores graph nodes level by level, visiting all neighbors before moving to the next depth level.</p>
            </div>

            <div class="controls">
                <select id="graphAlgorithm" onchange="updateGraphInfo()">
                    <option value="bfs">BFS Traversal</option>
                    <option value="dfs">DFS Traversal</option>
                    <option value="topological">Topological Sort</option>
                    <option value="dijkstraGraph">Shortest Path (Dijkstra)</option>
                    <option value="mst">Minimum Spanning Tree</option>
                </select>
                <button onclick="generateGraph()">Generate Graph</button>
                <button onclick="generateWeightedGraph()">Weighted Graph</button>
                <button id="graphBtn" onclick="startGraphTraversal()" class="success">Start Traversal</button>
                <button onclick="resetGraph()" class="danger">Reset</button>
                <div class="slider-container">
                    <label>Speed:</label>
                    <input type="range" id="graphSpeedSlider" min="1" max="100" value="50">
                    <span id="graphSpeedValue">50ms</span>
                </div>
            </div>
            <canvas id="graphCanvas" width="1200" height="550"></canvas>
        </div>

        <!-- Binary Tree Tab -->
        <div id="tree" class="tab-content">
            <div class="algorithm-info">
                <h3 id="treeTitle">Binary Search Tree</h3>
                <p id="treeDescription">A hierarchical data structure where each node has at most two children, with left child smaller and right child larger than parent.</p>
            </div>

            <div class="controls">
                <select id="treeAlgorithm" onchange="updateTreeInfo()">
                    <option value="insert">Insert Node</option>
                    <option value="search">Search Node</option>
                    <option value="delete">Delete Node</option>
                    <option value="inorder">In-order Traversal</option>
                    <option value="preorder">Pre-order Traversal</option>
                    <option value="postorder">Post-order Traversal</option>
                    <option value="levelorder">Level-order Traversal</option>
                </select>
                <input type="number" id="nodeValue" placeholder="Node value" min="1" max="100" value="50">
                <button onclick="executeTreeOperation()" class="success">Execute</button>
                <button onclick="generateRandomTree()">Random Tree</button>
                <button onclick="clearTree()" class="danger">Clear Tree</button>
                <div class="slider-container">
                    <label>Speed:</label>
                    <input type="range" id="treeSpeedSlider" min="1" max="100" value="60">
                    <span id="treeSpeedValue">60ms</span>
                </div>
            </div>
            <canvas id="treeCanvas" width="1200" height="500"></canvas>
        </div>
    </div>

    <script>
        // Global variables
        let array = [];
        let isAnimating = false;
        let animationId;
        let soundEnabled = true;
        let startTime, endTime;

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');
        const treeCanvas = document.getElementById('treeCanvas');
        const treeCtx = treeCanvas.getContext('2d');

        // Statistics
        let comparisons = 0;
        let swaps = 0;

        // Pathfinding grid
        const GRID_SIZE = 30;
        let grid = [];
        let startNode = {x: 5, y: 5};
        let endNode = {x: 25, y: 20};

        // Graph variables
        let nodes = [];
        let edges = [];
        let visitedNodes = [];

        // Tree variables
        let treeRoot = null;
        let treeNodes = [];

        // Algorithm descriptions
        const sortingAlgorithms = {
            bubble: {
                title: "Bubble Sort",
                description: "Compares adjacent elements and swaps them if they're in wrong order. Simple but inefficient for large datasets.",
                timeComplexity: "O(n²)",
                spaceComplexity: "O(1)",
                stability: "Stable"
            },
            selection: {
                title: "Selection Sort",
                description: "Finds the minimum element and places it at the beginning. Divides array into sorted and unsorted regions.",
                timeComplexity: "O(n²)",
                spaceComplexity: "O(1)",
                stability: "Unstable"
            },
            insertion: {
                title: "Insertion Sort",
                description: "Builds sorted array one element at a time by inserting each element into its correct position.",
                timeComplexity: "O(n²)",
                spaceComplexity: "O(1)",
                stability: "Stable"
            },
            merge: {
                title: "Merge Sort",
                description: "Divides array into halves, sorts them separately, then merges them back together. Divide-and-conquer approach.",
                timeComplexity: "O(n log n)",
                spaceComplexity: "O(n)",
                stability: "Stable"
            },
            quick: {
                title: "Quick Sort",
                description: "Selects a pivot element and partitions array around it. Efficient divide-and-conquer algorithm.",
                timeComplexity: "O(n log n)",
                spaceComplexity: "O(log n)",
                stability: "Unstable"
            },
            heap: {
                title: "Heap Sort",
                description: "Uses a binary heap data structure. Builds max-heap then repeatedly extracts maximum element.",
                timeComplexity: "O(n log n)",
                spaceComplexity: "O(1)",
                stability: "Unstable"
            },
            radix: {
                title: "Radix Sort",
                description: "Sorts by processing digits from least to most significant. Efficient for integers with fixed number of digits.",
                timeComplexity: "O(d × n)",
                spaceComplexity: "O(n + k)",
                stability: "Stable"
            },
            shell: {
                title: "Shell Sort",
                description: "Improved insertion sort that allows exchange of far apart elements. Uses gap sequence to reduce comparisons.",
                timeComplexity: "O(n³/²)",
                spaceComplexity: "O(1)",
                stability: "Unstable"
            }
        };

        const pathfindingAlgorithms = {
            astar: {
                title: "A* Search",
                description: "Informed search using heuristics (f = g + h). Finds optimal path efficiently by estimating remaining cost."
            },
            dijkstra: {
                title: "Dijkstra's Algorithm",
                description: "Finds shortest path from source to all vertices. Guarantees optimal solution using greedy approach."
            },
            bfs: {
                title: "Breadth-First Search",
                description: "Explores nodes level by level. Guarantees shortest path in unweighted graphs using queue."
            },
            dfs: {
                title: "Depth-First Search",
                description: "Explores as far as possible before backtracking. Uses stack (recursion) to traverse graph."
            },
            greedy: {
                title: "Greedy Best-First",
                description: "Uses only heuristic function (h) to guide search. Fast but doesn't guarantee optimal path."
            },
            bidirectional: {
                title: "Bidirectional Search",
                description: "Searches simultaneously from start and end points. Reduces search space significantly."
            }
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            generateArray();
            setupSliders();
            initializeGrid();
            generateGraph();
            updateSortingInfo();
        });

        function toggleSound() {
            soundEnabled = !soundEnabled;
            const btn = document.querySelector('.sound-toggle');
            btn.textContent = soundEnabled ? '🔊' : '🔇';
        }

        function playSound(frequency, duration = 100) {
            if (!soundEnabled) return;

            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration / 1000);
            } catch (e) {
                // Audio not supported
            }
        }

        function showTab(tabName) {
            // Hide all tab contents
            const contents = document.querySelectorAll('.tab-content');
            contents.forEach(content => content.classList.remove('active'));

            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));

            // Show selected tab content
            document.getElementById(tabName).classList.add('active');

            // Add active class to clicked tab
            event.target.classList.add('active');

            // Stop any running animations
            stopSort();
            stopPathfinding();
            stopGraph();
        }

        function setupSliders() {
            const speedSlider = document.getElementById('speedSlider');
            const sizeSlider = document.getElementById('sizeSlider');
            const pathSpeedSlider = document.getElementById('pathSpeedSlider');
            const graphSpeedSlider = document.getElementById('graphSpeedSlider');
            const treeSpeedSlider = document.getElementById('treeSpeedSlider');

            speedSlider.addEventListener('input', () => {
                document.getElementById('speedValue').textContent = speedSlider.value + 'ms';
            });

            sizeSlider.addEventListener('input', () => {
                document.getElementById('sizeValue').textContent = sizeSlider.value;
                generateArray();
            });

            pathSpeedSlider.addEventListener('input', () => {
                document.getElementById('pathSpeedValue').textContent = pathSpeedSlider.value + 'ms';
            });

            graphSpeedSlider.addEventListener('input', () => {
                document.getElementById('graphSpeedValue').textContent = graphSpeedSlider.value + 'ms';
            });

            treeSpeedSlider.addEventListener('input', () => {
                document.getElementById('treeSpeedValue').textContent = treeSpeedSlider.value + 'ms';
            });
        }

        function updateSortingInfo() {
            const algorithm = document.getElementById('sortAlgorithm').value;
            const info = sortingAlgorithms[algorithm];

            document.getElementById('sortingTitle').textContent = info.title;
            document.getElementById('sortingDescription').textContent = info.description;
            document.getElementById('timeComplexity').textContent = info.timeComplexity;
            document.getElementById('spaceComplexity').textContent = info.spaceComplexity;
            document.getElementById('stability').textContent = info.stability;
        }

        function updatePathInfo() {
            const algorithm = document.getElementById('pathAlgorithm').value;
            const info = pathfindingAlgorithms[algorithm];

            document.getElementById('pathTitle').textContent = info.title;
            document.getElementById('pathDescription').textContent = info.description;
        }

        function updateGraphInfo() {
            const algorithm = document.getElementById('graphAlgorithm').value;
            const titles = {
                bfs: "BFS Traversal",
                dfs: "DFS Traversal",
                topological: "Topological Sort",
                dijkstraGraph: "Dijkstra's Shortest Path",
                mst: "Minimum Spanning Tree (Kruskal's)"
            };

            const descriptions = {
                bfs: "Breadth-First Search explores graph nodes level by level, visiting all neighbors before moving to the next depth level.",
                dfs: "Depth-First Search explores as far as possible along each branch before backtracking to explore other branches.",
                topological: "Orders vertices in a directed acyclic graph such that for every directed edge (u,v), vertex u comes before v.",
                dijkstraGraph: "Finds shortest paths from a source vertex to all other vertices in a weighted graph with non-negative edge weights.",
                mst: "Finds the minimum spanning tree that connects all vertices with the minimum total edge weight."
            };

            document.getElementById('graphTitle').textContent = titles[algorithm];
            document.getElementById('graphDescription').textContent = descriptions[algorithm];
        }

        function updateTreeInfo() {
            const operation = document.getElementById('treeAlgorithm').value;
            const titles = {
                insert: "Insert Node",
                search: "Search Node",
                delete: "Delete Node",
                inorder: "In-order Traversal",
                preorder: "Pre-order Traversal",
                postorder: "Post-order Traversal",
                levelorder: "Level-order Traversal"
            };

            const descriptions = {
                insert: "Adds a new node to the binary search tree while maintaining the BST property.",
                search: "Finds a specific value in the binary search tree using the BST property for efficient searching.",
                delete: "Removes a node from the BST while maintaining the tree structure and BST property.",
                inorder: "Visits nodes in ascending order: left subtree, root, right subtree (gives sorted sequence).",
                preorder: "Visits root first, then left subtree, then right subtree (useful for copying tree structure).",
                postorder: "Visits left subtree, right subtree, then root (useful for deleting or calculating tree size).",
                levelorder: "Visits nodes level by level from top to bottom, left to right (breadth-first approach)."
            };

            document.getElementById('treeTitle').textContent = titles[operation];
            document.getElementById('treeDescription').textContent = descriptions[operation];
        }

        // ===== SORTING ALGORITHMS =====

        function generateArray() {
            const size = parseInt(document.getElementById('sizeSlider').value);
            array = [];
            for (let i = 0; i < size; i++) {
                array.push(Math.floor(Math.random() * 400) + 10);
            }
            resetStats();
            drawArray();
        }

        function resetStats() {
            comparisons = 0;
            swaps = 0;
            document.getElementById('comparisons').textContent = '0';
            document.getElementById('swaps').textContent = '0';
            document.getElementById('elapsedTime').textContent = '0ms';
            document.getElementById('sortProgress').style.width = '0%';
        }

        function drawArray(compareIndices = [], swapIndices = [], sortedIndices = []) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const barWidth = canvas.width / array.length;

            for (let i = 0; i < array.length; i++) {
                const barHeight = array[i];
                let color = '#4ecdc4';

                if (sortedIndices.includes(i)) {
                    color = '#6bcf7f';
                } else if (swapIndices.includes(i)) {
                    color = '#ff6b6b';
                } else if (compareIndices.includes(i)) {
                    color = '#ffd93d';
                }

                // Add gradient effect
                const gradient = ctx.createLinearGradient(0, canvas.height - barHeight, 0, canvas.height);
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, color + '80');

                ctx.fillStyle = gradient;
                ctx.fillRect(i * barWidth, canvas.height - barHeight, barWidth - 1, barHeight);

                // Add glow effect for active bars
                if (compareIndices.includes(i) || swapIndices.includes(i)) {
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 15;
                    ctx.fillRect(i * barWidth, canvas.height - barHeight, barWidth - 1, barHeight);
                    ctx.shadowBlur = 0;
                }
            }
        }

        async function startSort() {
            if (isAnimating) return;

            isAnimating = true;
            startTime = performance.now();
            document.getElementById('sortBtn').disabled = true;

            const algorithm = document.getElementById('sortAlgorithm').value;

            switch (algorithm) {
                case 'bubble': await bubbleSort(); break;
                case 'selection': await selectionSort(); break;
                case 'insertion': await insertionSort(); break;
                case 'merge': await mergeSort(0, array.length - 1); break;
                case 'quick': await quickSort(0, array.length - 1); break;
                case 'heap': await heapSort(); break;
                case 'radix': await radixSort(); break;
                case 'shell': await shellSort(); break;
            }

            // Victory animation
            await celebrateSort();

            endTime = performance.now();
            document.getElementById('elapsedTime').textContent = Math.round(endTime - startTime) + 'ms';
            document.getElementById('sortProgress').style.width = '100%';

            isAnimating = false;
            document.getElementById('sortBtn').disabled = false;
        }

        function stopSort() {
            isAnimating = false;
            document.getElementById('sortBtn').disabled = false;
            if (animationId) {
                clearTimeout(animationId);
            }
        }

        async function sleep(ms) {
            return new Promise(resolve => {
                animationId = setTimeout(resolve, ms);
            });
        }

        function updateProgress(currentIndex, totalLength) {
            const progress = (currentIndex / totalLength) * 100;
            document.getElementById('sortProgress').style.width = progress + '%';
        }

        // Enhanced sorting algorithms with better visualization

        async function bubbleSort() {
            for (let i = 0; i < array.length - 1 && isAnimating; i++) {
                for (let j = 0; j < array.length - i - 1 && isAnimating; j++) {
                    comparisons++;
                    document.getElementById('comparisons').textContent = comparisons;
                    playSound(200 + array[j] * 2, 50);

                    updateProgress(i * array.length + j, array.length * array.length);
                    drawArray([j, j + 1]);
                    await sleep(101 - parseInt(document.getElementById('speedSlider').value));

                    if (array[j] > array[j + 1]) {
                        [array[j], array[j + 1]] = [array[j + 1], array[j]];
                        swaps++;
                        document.getElementById('swaps').textContent = swaps;
                        playSound(400, 80);
                        drawArray([], [j, j + 1]);
                        await sleep(101 - parseInt(document.getElementById('speedSlider').value));
                    }
                }
                // Mark as sorted
                const sortedIndices = [];
                for (let k = array.length - i - 1; k < array.length; k++) {
                    sortedIndices.push(k);
                }
                drawArray([], [], sortedIndices);
                await sleep(50);
            }
        }

        async function selectionSort() {
            for (let i = 0; i < array.length - 1 && isAnimating; i++) {
                let minIdx = i;
                for (let j = i + 1; j < array.length && isAnimating; j++) {
                    comparisons++;
                    document.getElementById('comparisons').textContent = comparisons;
                    playSound(200 + array[j] * 2, 40);

                    updateProgress(i * array.length + j, array.length * array.length);
                    drawArray([i, j, minIdx]);
                    await sleep(101 - parseInt(document.getElementById('speedSlider').value));

                    if (array[j] < array[minIdx]) {
                        minIdx = j;
                    }
                }

                if (minIdx !== i) {
                    [array[i], array[minIdx]] = [array[minIdx], array[i]];
                    swaps++;
                    document.getElementById('swaps').textContent = swaps;
                    playSound(400, 100);
                    drawArray([], [i, minIdx]);
                    await sleep(101 - parseInt(document.getElementById('speedSlider').value));
                }

                // Mark current position as sorted
                const sortedIndices = [];
                for (let k = 0; k <= i; k++) {
                    sortedIndices.push(k);
                }
                drawArray([], [], sortedIndices);
            }
        }

        async function insertionSort() {
            const sortedIndices = [0];
            drawArray([], [], sortedIndices);

            for (let i = 1; i < array.length && isAnimating; i++) {
                let key = array[i];
                let j = i - 1;

                while (j >= 0 && array[j] > key && isAnimating) {
                    comparisons++;
                    document.getElementById('comparisons').textContent = comparisons;
                    playSound(200 + array[j] * 2, 30);

                    array[j + 1] = array[j];
                    swaps++;
                    document.getElementById('swaps').textContent = swaps;

                    updateProgress(i, array.length);
                    drawArray([j, j + 1], [], sortedIndices);
                    await sleep(101 - parseInt(document.getElementById('speedSlider').value));

                    j--;
                }
                array[j + 1] = key;
                sortedIndices.push(i);
                drawArray([], [], sortedIndices);
                await sleep(50);
            }
        }

        async function mergeSort(left, right) {
            if (left >= right || !isAnimating) return;

            const mid = Math.floor((left + right) / 2);
            await mergeSort(left, mid);
            await mergeSort(mid + 1, right);
            await merge(left, mid, right);
        }

        async function merge(left, mid, right) {
            const leftArray = array.slice(left, mid + 1);
            const rightArray = array.slice(mid + 1, right + 1);

            let i = 0, j = 0, k = left;

            while (i < leftArray.length && j < rightArray.length && isAnimating) {
                comparisons++;
                document.getElementById('comparisons').textContent = comparisons;
                playSound(150 + leftArray[i] * 1.5, 40);

                updateProgress(k, array.length);
                drawArray([left + i, mid + 1 + j]);
                await sleep(101 - parseInt(document.getElementById('speedSlider').value));

                if (leftArray[i] <= rightArray[j]) {
                    array[k] = leftArray[i];
                    i++;
                } else {
                    array[k] = rightArray[j];
                    j++;
                }

                swaps++;
                document.getElementById('swaps').textContent = swaps;
                drawArray([], [k]);
                await sleep(101 - parseInt(document.getElementById('speedSlider').value));
                k++;
            }

            while (i < leftArray.length && isAnimating) {
                array[k] = leftArray[i];
                swaps++;
                drawArray([], [k]);
                await sleep(50);
                i++;
                k++;
            }

            while (j < rightArray.length && isAnimating) {
                array[k] = rightArray[j];
                swaps++;
                drawArray([], [k]);
                await sleep(50);
                j++;
                k++;
            }
        }

        async function quickSort(low, high) {
            if (low < high && isAnimating) {
                const pi = await partition(low, high);
                await quickSort(low, pi - 1);
                await quickSort(pi + 1, high);
            }
        }

        async function partition(low, high) {
            const pivot = array[high];
            let i = low - 1;

            for (let j = low; j < high && isAnimating; j++) {
                comparisons++;
                document.getElementById('comparisons').textContent = comparisons;
                playSound(180 + array[j] * 1.8, 35);

                updateProgress(j, array.length);
                drawArray([j, high]);
                await sleep(101 - parseInt(document.getElementById('speedSlider').value));

                if (array[j] < pivot) {
                    i++;
                    [array[i], array[j]] = [array[j], array[i]];
                    swaps++;
                    document.getElementById('swaps').textContent = swaps;
                    playSound(350, 60);
                    drawArray([], [i, j]);
                    await sleep(101 - parseInt(document.getElementById('speedSlider').value));
                }
            }

            [array[i + 1], array[high]] = [array[high], array[i + 1]];
            swaps++;
            document.getElementById('swaps').textContent = swaps;
            drawArray([], [i + 1, high]);
            await sleep(101 - parseInt(document.getElementById('speedSlider').value));

            return i + 1;
        }

        async function heapSort() {
            const n = array.length;

            // Build max heap
            for (let i = Math.floor(n / 2) - 1; i >= 0 && isAnimating; i--) {
                await heapify(n, i);
            }

            // Extract elements from heap one by one
            for (let i = n - 1; i > 0 && isAnimating; i--) {
                [array[0], array[i]] = [array[i], array[0]];
                swaps++;
                document.getElementById('swaps').textContent = swaps;
                playSound(300, 80);

                updateProgress(n - i, n);
                const sortedIndices = [];
                for (let k = i; k < array.length; k++) {
                    sortedIndices.push(k);
                }
                drawArray([], [0, i], sortedIndices);
                await sleep(101 - parseInt(document.getElementById('speedSlider').value));

                await heapify(i, 0);
            }
        }

        async function heapify(n, i) {
            let largest = i;
            const left = 2 * i + 1;
            const right = 2 * i + 2;

            if (left < n) {
                comparisons++;
                document.getElementById('comparisons').textContent = comparisons;
                if (array[left] > array[largest]) {
                    largest = left;
                }
            }

            if (right < n) {
                comparisons++;
                document.getElementById('comparisons').textContent = comparisons;
                if (array[right] > array[largest]) {
                    largest = right;
                }
            }

            if (largest !== i && isAnimating) {
                [array[i], array[largest]] = [array[largest], array[i]];
                swaps++;
                document.getElementById('swaps').textContent = swaps;
                playSound(250, 60);
                drawArray([], [i, largest]);
                await sleep(101 - parseInt(document.getElementById('speedSlider').value));

                await heapify(n, largest);
            }
        }

        async function radixSort() {
            const max = Math.max(...array);

            for (let exp = 1; Math.floor(max / exp) > 0 && isAnimating; exp *= 10) {
                await countingSort(exp);
            }
        }

        async function countingSort(exp) {
            const n = array.length;
            const output = new Array(n);
            const count = new Array(10).fill(0);

            // Count occurrences
            for (let i = 0; i < n; i++) {
                count[Math.floor(array[i] / exp) % 10]++;
            }

            // Change count[i] to actual position
            for (let i = 1; i < 10; i++) {
                count[i] += count[i - 1];
            }

            // Build output array
            for (let i = n - 1; i >= 0 && isAnimating; i--) {
                const digit = Math.floor(array[i] / exp) % 10;
                output[count[digit] - 1] = array[i];
                count[digit]--;

                updateProgress(n - i, n);
                drawArray([i]);
                await sleep(101 - parseInt(document.getElementById('speedSlider').value));
            }

            // Copy output array to array
            for (let i = 0; i < n && isAnimating; i++) {
                array[i] = output[i];
                swaps++;
                document.getElementById('swaps').textContent = swaps;
                drawArray([], [i]);
                await sleep(50);
            }
        }

        async function shellSort() {
            const n = array.length;

            for (let gap = Math.floor(n / 2); gap > 0 && isAnimating; gap = Math.floor(gap / 2)) {
                for (let i = gap; i < n && isAnimating; i++) {
                    const temp = array[i];
                    let j;

                    for (j = i; j >= gap && array[j - gap] > temp && isAnimating; j -= gap) {
                        comparisons++;
                        document.getElementById('comparisons').textContent = comparisons;
                        playSound(180 + array[j] * 1.5, 30);

                        array[j] = array[j - gap];
                        swaps++;
                        document.getElementById('swaps').textContent = swaps;

                        updateProgress(i, n);
                        drawArray([j, j - gap]);
                        await sleep(101 - parseInt(document.getElementById('speedSlider').value));
                    }
                    array[j] = temp;
                }
            }
        }

        async function celebrateSort() {
            for (let i = 0; i < array.length && isAnimating; i++) {
                playSound(300 + i * 5, 30);
                const sortedIndices = [];
                for (let j = 0; j <= i; j++) {
                    sortedIndices.push(j);
                }
                drawArray([], [], sortedIndices);
                await sleep(20);
            }
            drawArray([], [], Array.from({length: array.length}, (_, i) => i));
        }

        // ===== PATHFINDING ALGORITHMS =====

        function initializeGrid() {
            const gridElement = document.getElementById('pathGrid');
            gridElement.innerHTML = '';
            gridElement.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 20px)`;

            grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                grid[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;

                    if (x === startNode.x && y === startNode.y) {
                        cell.classList.add('start');
                    } else if (x === endNode.x && y === endNode.y) {
                        cell.classList.add('end');
                    }

                    cell.addEventListener('click', handleCellClick);
                    cell.addEventListener('contextmenu', handleRightClick);
                    cell.addEventListener('mousedown', handleMouseDown);
                    cell.addEventListener('mouseenter', handleMouseEnter);
                    gridElement.appendChild(cell);

                    grid[y][x] = {
                        x, y,
                        wall: false,
                        visited: false,
                        distance: Infinity,
                        heuristic: 0,
                        parent: null,
                        element: cell,
                        weight: 1
                    };
                }
            }
        }

        let isDragging = false;
        let dragType = '';

        function handleMouseDown(event) {
            const x = parseInt(event.target.dataset.x);
            const y = parseInt(event.target.dataset.y);

            if (x === startNode.x && y === startNode.y) {
                isDragging = true;
                dragType = 'start';
            } else if (x === endNode.x && y === endNode.y) {
                isDragging = true;
                dragType = 'end';
            }
        }

        function handleMouseEnter(event) {
            if (!isDragging) return;

            const x = parseInt(event.target.dataset.x);
            const y = parseInt(event.target.dataset.y);

            if (dragType === 'start') {
                // Remove old start
                grid[startNode.y][startNode.x].element.classList.remove('start');
                startNode = {x, y};
                event.target.classList.add('start');
                event.target.classList.remove('wall', 'end');
                grid[y][x].wall = false;
            } else if (dragType === 'end') {
                // Remove old end
                grid[endNode.y][endNode.x].element.classList.remove('end');
                endNode = {x, y};
                event.target.classList.add('end');
                event.target.classList.remove('wall', 'start');
                grid[y][x].wall = false;
            }
        }

        document.addEventListener('mouseup', () => {
            isDragging = false;
            dragType = '';
        });

        function handleCellClick(event) {
            const x = parseInt(event.target.dataset.x);
            const y = parseInt(event.target.dataset.y);

            if ((x === startNode.x && y === startNode.y) || (x === endNode.x && y === endNode.y)) {
                return;
            }

            const cell = grid[y][x];
            cell.wall = !cell.wall;
            event.target.classList.toggle('wall');
        }

        function handleRightClick(event) {
            event.preventDefault();
            const x = parseInt(event.target.dataset.x);
            const y = parseInt(event.target.dataset.y);

            if ((x === startNode.x && y === startNode.y) || (x === endNode.x && y === endNode.y)) {
                return;
            }

            const cell = grid[y][x];
            cell.weight = cell.weight === 1 ? 3 : 1;

            if (cell.weight === 3 && !cell.wall) {
                event.target.style.background = '#ffa500';
                event.target.style.opacity = '0.7';
            } else {
                event.target.style.background = '';
                event.target.style.opacity = '';
            }
        }

        function generateMaze() {
            clearGrid();

            // Simple recursive maze generation
            const stack = [];
            const visited = new Set();

            function getNeighbors(x, y) {
                const neighbors = [];
                const directions = [[-2, 0], [2, 0], [0, -2], [0, 2]];

                for (const [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && !visited.has(`${nx},${ny}`)) {
                        neighbors.push({x: nx, y: ny, wallX: x + dx/2, wallY: y + dy/2});
                    }
                }
                return neighbors;
            }

            // Fill with walls
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if ((x === startNode.x && y === startNode.y) || (x === endNode.x && y === endNode.y)) {
                        continue;
                    }
                    grid[y][x].wall = true;
                    grid[y][x].element.classList.add('wall');
                }
            }

            // Start carving from a random odd position
            let currentX = 1;
            let currentY = 1;
            visited.add(`${currentX},${currentY}`);
            stack.push({x: currentX, y: currentY});

            grid[currentY][currentX].wall = false;
            grid[currentY][currentX].element.classList.remove('wall');

            while (stack.length > 0) {
                const neighbors = getNeighbors(currentX, currentY);

                if (neighbors.length > 0) {
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];

                    // Remove wall between current and next
                    grid[next.wallY][next.wallX].wall = false;
                    grid[next.wallY][next.wallX].element.classList.remove('wall');

                    grid[next.y][next.x].wall = false;
                    grid[next.y][next.x].element.classList.remove('wall');

                    visited.add(`${next.x},${next.y}`);
                    stack.push({x: next.x, y: next.y});
                    currentX = next.x;
                    currentY = next.y;
                } else {
                    const backtrack = stack.pop();
                    if (backtrack) {
                        currentX = backtrack.x;
                        currentY = backtrack.y;
                    }
                }
            }

            // Ensure start and end are clear
            grid[startNode.y][startNode.x].wall = false;
            grid[startNode.y][startNode.x].element.classList.remove('wall');
            grid[endNode.y][endNode.x].wall = false;
            grid[endNode.y][endNode.x].element.classList.remove('wall');
        }

        <!-- The existing HTML and CSS code remains the same until the script section -->


    function addRandomWalls() {
        clearPath();
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                if ((x === startNode.x && y === startNode.y) || (x === endNode.x && y === endNode.y)) {
                    continue;
                }
                if (Math.random() < 0.3) { // 30% chance of wall
                    grid[y][x].wall = true;
                    grid[y][x].element.classList.add('wall');
                }
            }
        }
    }

    function clearPath() {
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                const cell = grid[y][x];
                cell.visited = false;
                cell.distance = Infinity;
                cell.heuristic = 0;
                cell.parent = null;
                cell.element.classList.remove('visited', 'path');

                // Reset weight but keep walls
                cell.weight = 1;
                if (!cell.wall) {
                    cell.element.style.background = '';
                    cell.element.style.opacity = '';
                }
            }
        }
    }

    function clearGrid() {
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                const cell = grid[y][x];
                cell.wall = false;
                cell.visited = false;
                cell.distance = Infinity;
                cell.heuristic = 0;
                cell.parent = null;
                cell.weight = 1;
                cell.element.className = 'cell';
                cell.element.style.background = '';
                cell.element.style.opacity = '';

                if (x === startNode.x && y === startNode.y) {
                    cell.element.classList.add('start');
                } else if (x === endNode.x && y === endNode.y) {
                    cell.element.classList.add('end');
                }
            }
        }
    }

    async function startPathfinding() {
        if (isAnimating) return;

        isAnimating = true;
        clearPath();
        document.getElementById('pathBtn').disabled = true;

        const algorithm = document.getElementById('pathAlgorithm').value;
        const speed = 101 - parseInt(document.getElementById('pathSpeedSlider').value);

        switch (algorithm) {
            case 'astar': await aStarSearch(); break;
            case 'dijkstra': await dijkstra(); break;
            case 'bfs': await breadthFirstSearch(); break;
            case 'dfs': await depthFirstSearch(); break;
            case 'greedy': await greedyBestFirst(); break;
            case 'bidirectional': await bidirectionalSearch(); break;
        }

        isAnimating = false;
        document.getElementById('pathBtn').disabled = false;
    }

    function stopPathfinding() {
        isAnimating = false;
        document.getElementById('pathBtn').disabled = false;
        if (animationId) {
            clearTimeout(animationId);
        }
    }

    function heuristic(nodeA, nodeB) {
        // Manhattan distance
        return Math.abs(nodeA.x - nodeB.x) + Math.abs(nodeA.y - nodeB.y);
    }

     async function bidirectionalSearch() {
            // Implementation of bidirectional search algorithm
            const forwardQueue = [];
            const backwardQueue = [];
            const forwardVisited = new Set();
            const backwardVisited = new Set();
            const forwardParents = new Map();
            const backwardParents = new Map();

            const start = grid[startNode.y][startNode.x];
            const end = grid[endNode.y][endNode.x];

            forwardQueue.push(start);
            forwardVisited.add(start);
            forwardParents.set(start, null);

            backwardQueue.push(end);
            backwardVisited.add(end);
            backwardParents.set(end, null);

            let meetingNode = null;
            const speed = 101 - parseInt(document.getElementById('pathSpeedSlider').value);

            while ((forwardQueue.length > 0 || backwardQueue.length > 0) && isAnimating) {
                // Process forward search
                if (forwardQueue.length > 0) {
                    const currentForward = forwardQueue.shift();

                    if (backwardVisited.has(currentForward)) {
                        meetingNode = currentForward;
                        break;
                    }

                    currentForward.element.classList.add('visited');
                    playSound(300, 20);
                    await sleep(speed);

                    for (const neighbor of getNeighbors(currentForward)) {
                        if (!forwardVisited.has(neighbor)) {
                            forwardVisited.add(neighbor);
                            forwardParents.set(neighbor, currentForward);
                            forwardQueue.push(neighbor);
                        }
                    }
                }

                // Process backward search
                if (backwardQueue.length > 0) {
                    const currentBackward = backwardQueue.shift();

                    if (forwardVisited.has(currentBackward)) {
                        meetingNode = currentBackward;
                        break;
                    }

                    currentBackward.element.classList.add('visited');
                    playSound(300, 20);
                    await sleep(speed);

                    for (const neighbor of getNeighbors(currentBackward)) {
                        if (!backwardVisited.has(neighbor)) {
                            backwardVisited.add(neighbor);
                            backwardParents.set(neighbor, currentBackward);
                            backwardQueue.push(neighbor);
                        }
                    }
                }
            }

            if (meetingNode) {
                // Reconstruct path from start to meeting point
                let current = meetingNode;
                while (current && current !== start) {
                    current.element.classList.add('path');
                    current = forwardParents.get(current);
                    await sleep(speed / 2);
                }

                // Reconstruct path from meeting point to end
                current = meetingNode;
                while (current && current !== end) {
                    current.element.classList.add('path');
                    current = backwardParents.get(current);
                    await sleep(speed / 2);
                }

                playSound(600, 100);
            } else {
                // No path found
                playSound(100, 200);
            }

            isAnimating = false;
            document.getElementById('pathBtn').disabled = false;
        }

    async function aStarSearch() {
        const openSet = new PriorityQueue();
        const closedSet = new Set();
        const start = grid[startNode.y][startNode.x];
        const end = grid[endNode.y][endNode.x];

        start.distance = 0;
        start.heuristic = heuristic(start, end);
        openSet.enqueue(start, start.distance + start.heuristic);

        const speed = 101 - parseInt(document.getElementById('pathSpeedSlider').value);

        while (!openSet.isEmpty() && isAnimating) {
            const current = openSet.dequeue().element;

            if (current === end) {
                await reconstructPath(current);
                return;
            }

            closedSet.add(current);
            current.element.classList.add('visited');
            playSound(300, 20);
            await sleep(speed);

            for (const neighbor of getNeighbors(current)) {
                if (closedSet.has(neighbor)) continue;

                const tentativeDistance = current.distance + neighbor.weight;

                if (tentativeDistance < neighbor.distance) {
                    neighbor.distance = tentativeDistance;
                    neighbor.heuristic = heuristic(neighbor, end);
                    neighbor.parent = current;

                    if (!openSet.contains(neighbor)) {
                        openSet.enqueue(neighbor, neighbor.distance + neighbor.heuristic);
                    } else {
                        openSet.updatePriority(neighbor, neighbor.distance + neighbor.heuristic);
                    }
                }
            }
        }

        // No path found
        playSound(100, 200);
    }

    function getNeighbors(node) {
        const neighbors = [];
        const directions = [
            {x: 0, y: -1}, // Up
            {x: 1, y: 0},  // Right
            {x: 0, y: 1},  // Down
            {x: -1, y: 0}  // Left
        ];

        for (const dir of directions) {
            const newX = node.x + dir.x;
            const newY = node.y + dir.y;

            if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                const neighbor = grid[newY][newX];
                if (!neighbor.wall) {
                    neighbors.push(neighbor);
                }
            }
        }

        return neighbors;
    }

    async function reconstructPath(node) {
        let current = node;
        const path = [];

        while (current.parent) {
            path.unshift(current);
            current = current.parent;
        }

        const speed = 101 - parseInt(document.getElementById('pathSpeedSlider').value);

        for (const pathNode of path) {
            if (pathNode !== grid[startNode.y][startNode.x] && pathNode !== grid[endNode.y][endNode.x]) {
                pathNode.element.classList.add('path');
                playSound(500, 30);
                await sleep(speed / 2);
            }
        }
    }

    // Priority Queue implementation for A*
    class PriorityQueue {
        constructor() {
            this.elements = [];
        }

        enqueue(element, priority) {
            this.elements.push({element, priority});
            this.elements.sort((a, b) => a.priority - b.priority);
        }

        dequeue() {
            return this.elements.shift();
        }

        isEmpty() {
            return this.elements.length === 0;
        }

        contains(element) {
            return this.elements.some(item => item.element === element);
        }

        updatePriority(element, newPriority) {
            const index = this.elements.findIndex(item => item.element === element);
            if (index !== -1) {
                this.elements[index].priority = newPriority;
                this.elements.sort((a, b) => a.priority - b.priority);
            }
        }
    }

    // Other pathfinding algorithms would be implemented similarly
    async function dijkstra() {
        // Implementation similar to A* but without heuristic
        const priorityQueue = new PriorityQueue();
        const start = grid[startNode.y][startNode.x];
        const end = grid[endNode.y][endNode.x];

        start.distance = 0;
        priorityQueue.enqueue(start, start.distance);

        const speed = 101 - parseInt(document.getElementById('pathSpeedSlider').value);

        while (!priorityQueue.isEmpty() && isAnimating) {
            const current = priorityQueue.dequeue().element;

            if (current.visited) continue;
            current.visited = true;

            current.element.classList.add('visited');
            playSound(300, 20);
            await sleep(speed);

            if (current === end) {
                await reconstructPath(current);
                return;
            }

            for (const neighbor of getNeighbors(current)) {
                if (neighbor.visited) continue;

                const distance = current.distance + neighbor.weight;

                if (distance < neighbor.distance) {
                    neighbor.distance = distance;
                    neighbor.parent = current;
                    priorityQueue.enqueue(neighbor, neighbor.distance);
                }
            }
        }

        // No path found
        playSound(100, 200);
    }

    async function breadthFirstSearch() {
        const queue = [];
        const start = grid[startNode.y][startNode.x];
        const end = grid[endNode.y][endNode.x];

        start.visited = true;
        queue.push(start);

        const speed = 101 - parseInt(document.getElementById('pathSpeedSlider').value);

        while (queue.length > 0 && isAnimating) {
            const current = queue.shift();

            if (current === end) {
                await reconstructPath(current);
                return;
            }

            for (const neighbor of getNeighbors(current)) {
                if (!neighbor.visited) {
                    neighbor.visited = true;
                    neighbor.parent = current;
                    queue.push(neighbor);

                    neighbor.element.classList.add('visited');
                    playSound(300, 20);
                    await sleep(speed);
                }
            }
        }

        // No path found
        playSound(100, 200);
    }

    async function depthFirstSearch() {
        const stack = [];
        const start = grid[startNode.y][startNode.x];
        const end = grid[endNode.y][endNode.x];

        start.visited = true;
        stack.push(start);

        const speed = 101 - parseInt(document.getElementById('pathSpeedSlider').value);

        while (stack.length > 0 && isAnimating) {
            const current = stack.pop();

            if (current === end) {
                await reconstructPath(current);
                return;
            }

            for (const neighbor of getNeighbors(current)) {
                if (!neighbor.visited) {
                    neighbor.visited = true;
                    neighbor.parent = current;
                    stack.push(neighbor);

                    neighbor.element.classList.add('visited');
                    playSound(300, 20);
                    await sleep(speed);
                }
            }
        }

        // No path found
        playSound(100, 200);
    }

    async function greedyBestFirst() {
        const priorityQueue = new PriorityQueue();
        const start = grid[startNode.y][startNode.x];
        const end = grid[endNode.y][endNode.x];

        start.heuristic = heuristic(start, end);
        priorityQueue.enqueue(start, start.heuristic);

        const speed = 101 - parseInt(document.getElementById('pathSpeedSlider').value);

        while (!priorityQueue.isEmpty() && isAnimating) {
            const current = priorityQueue.dequeue().element;

            if (current.visited) continue;
            current.visited = true;

            current.element.classList.add('visited');
            playSound(300, 20);
            await sleep(speed);

            if (current === end) {
                await reconstructPath(current);
                return;
            }

            for (const neighbor of getNeighbors(current)) {
                if (!neighbor.visited) {
                    neighbor.heuristic = heuristic(neighbor, end);
                    neighbor.parent = current;
                    priorityQueue.enqueue(neighbor, neighbor.heuristic);
                }
            }
        }

        // No path found
        playSound(100, 200);
    }

    

    // ===== GRAPH TRAVERSAL ALGORITHMS =====

    function generateGraph() {
        nodes = [];
        edges = [];
        visitedNodes = [];

        // Create random nodes
        const nodeCount = Math.floor(Math.random() * 15) + 10; // 10-24 nodes
        for (let i = 0; i < nodeCount; i++) {
            nodes.push({
                id: i,
                x: Math.random() * graphCanvas.width,
                y: Math.random() * graphCanvas.height,
                visited: false,
                distance: Infinity,
                parent: null
            });
        }

        // Create random edges
        for (let i = 0; i < nodes.length; i++) {
            const edgeCount = Math.floor(Math.random() * 3) + 2; // 2-4 edges per node
            for (let j = 0; j < edgeCount; j++) {
                const target = Math.floor(Math.random() * nodes.length);
                if (target !== i) {
                    edges.push({
                        source: i,
                        target: target,
                        weight: Math.floor(Math.random() * 9) + 1 // 1-9 weight
                    });
                }
            }
        }

        drawGraph();
    }

    function generateWeightedGraph() {
        generateGraph();
        // Ensure some edges have higher weights
        for (const edge of edges) {
            if (Math.random() < 0.3) { // 30% chance of higher weight
                edge.weight = Math.floor(Math.random() * 20) + 10; // 10-29 weight
            }
        }
        drawGraph();
    }

    function resetGraph() {
        for (const node of nodes) {
            node.visited = false;
            node.distance = Infinity;
            node.parent = null;
        }
        visitedNodes = [];
        drawGraph();
    }

    function drawGraph() {
        graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);

        // Draw edges
        graphCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        graphCtx.lineWidth = 2;
        graphCtx.font = '12px Arial';
        graphCtx.fillStyle = 'white';

        for (const edge of edges) {
            const source = nodes[edge.source];
            const target = nodes[edge.target];

            graphCtx.beginPath();
            graphCtx.moveTo(source.x, source.y);
            graphCtx.lineTo(target.x, target.y);
            graphCtx.stroke();

            // Draw weight
            const midX = (source.x + target.x) / 2;
            const midY = (source.y + target.y) / 2;
            graphCtx.fillText(edge.weight.toString(), midX + 5, midY + 5);
        }

        // Draw nodes
        for (const node of nodes) {
            graphCtx.beginPath();
            graphCtx.arc(node.x, node.y, 15, 0, Math.PI * 2);

            if (node.visited) {
                graphCtx.fillStyle = '#ffd93d';
            } else if (visitedNodes.includes(node.id)) {
                graphCtx.fillStyle = '#6bcf7f';
            } else {
                graphCtx.fillStyle = '#4ecdc4';
            }

            graphCtx.fill();
            graphCtx.strokeStyle = 'white';
            graphCtx.lineWidth = 2;
            graphCtx.stroke();

            // Draw node ID
            graphCtx.fillStyle = 'white';
            graphCtx.font = 'bold 14px Arial';
            graphCtx.textAlign = 'center';
            graphCtx.textBaseline = 'middle';
            graphCtx.fillText(node.id.toString(), node.x, node.y);
        }
    }

    async function startGraphTraversal() {
            if (isAnimating) return;

            isAnimating = true;
            resetGraph();

            const algorithm = document.getElementById('graphAlgorithm').value;
            const speed = 101 - parseInt(document.getElementById('graphSpeedSlider').value);

            switch (algorithm) {
                case 'bfs': await bfsTraversal(); break;
                case 'dfs': await dfsTraversal(); break;
                case 'topological': await topologicalSort(); break;
                case 'dijkstraGraph': await dijkstraGraph(); break;
                case 'mst': await mst(); break;
            }
        }

    function stopGraph() {
        isAnimating = false;
        if (animationId) {
            clearTimeout(animationId);
        }
    }
    async function topologicalSort() {
            resetGraph();
            const inDegree = new Array(nodes.length).fill(0);
            const queue = [];
            const result = [];
            const speed = 101 - parseInt(document.getElementById('graphSpeedSlider').value);

            // Calculate in-degrees
            for (const edge of edges) {
                inDegree[edge.target]++;
            }

            // Find nodes with zero in-degree
            for (let i = 0; i < nodes.length; i++) {
                if (inDegree[i] === 0) {
                    queue.push(nodes[i]);
                }
            }

            while (queue.length > 0 && isAnimating) {
                queue.sort((a, b) => a.id - b.id); // Process in order for consistent visualization
                const current = queue.shift();

                current.visited = true;
                visitedNodes.push(current.id);
                result.push(current.id);

                drawGraph();
                playSound(400, 50);
                await sleep(speed);

                // Reduce in-degree of neighbors
                for (const edge of edges) {
                    if (edge.source === current.id) {
                        inDegree[edge.target]--;
                        if (inDegree[edge.target] === 0) {
                            queue.push(nodes[edge.target]);
                        }
                    }
                }
            }

            if (result.length !== nodes.length) {
                // Graph has a cycle
                alert("Graph contains a cycle! Topological sort not possible.");
            }

            isAnimating = false;
        }

        async function dijkstraGraph() {
            resetGraph();
            const startNode = nodes[0]; // Start from first node
            startNode.distance = 0;

            const priorityQueue = new PriorityQueue();
            priorityQueue.enqueue(startNode, startNode.distance);

            const speed = 101 - parseInt(document.getElementById('graphSpeedSlider').value);

            while (!priorityQueue.isEmpty() && isAnimating) {
                const current = priorityQueue.dequeue().element;

                if (current.visited) continue;
                current.visited = true;
                visitedNodes.push(current.id);

                drawGraph();
                playSound(400, 50);
                await sleep(speed);

                // Update distances to neighbors
                for (const edge of edges) {
                    if (edge.source === current.id) {
                        const neighbor = nodes[edge.target];
                        const newDistance = current.distance + edge.weight;

                        if (newDistance < neighbor.distance) {
                            neighbor.distance = newDistance;
                            neighbor.parent = current;
                            priorityQueue.enqueue(neighbor, neighbor.distance);
                        }
                    } else if (edge.target === current.id) {
                        const neighbor = nodes[edge.source];
                        const newDistance = current.distance + edge.weight;

                        if (newDistance < neighbor.distance) {
                            neighbor.distance = newDistance;
                            neighbor.parent = current;
                            priorityQueue.enqueue(neighbor, neighbor.distance);
                        }
                    }
                }
            }

            // Highlight shortest paths
            for (const node of nodes) {
                if (node.parent !== null) {
                    node.highlighted = true;
                    drawGraph();
                    await sleep(speed / 2);
                }
            }

            isAnimating = false;
        }

        async function mst() {
            resetGraph();
            // Using Kruskal's algorithm for MST
            const sortedEdges = [...edges].sort((a, b) => a.weight - b.weight);
            const parent = new Array(nodes.length);
            const rank = new Array(nodes.length).fill(0);
            const mstEdges = [];
            const speed = 101 - parseInt(document.getElementById('graphSpeedSlider').value);

            // Initialize union-find data structure
            for (let i = 0; i < nodes.length; i++) {
                parent[i] = i;
            }

            function find(x) {
                if (parent[x] !== x) {
                    parent[x] = find(parent[x]);
                }
                return parent[x];
            }

            function union(x, y) {
                const rootX = find(x);
                const rootY = find(y);

                if (rootX === rootY) return false;

                if (rank[rootX] < rank[rootY]) {
                    parent[rootX] = rootY;
                } else if (rank[rootX] > rank[rootY]) {
                    parent[rootY] = rootX;
                } else {
                    parent[rootY] = rootX;
                    rank[rootX]++;
                }

                return true;
            }

            for (const edge of sortedEdges) {
                if (!isAnimating) break;

                if (union(edge.source, edge.target)) {
                    mstEdges.push(edge);

                    // Visualize the added edge
                    nodes[edge.source].highlighted = true;
                    nodes[edge.target].highlighted = true;

                    drawGraph();
                    playSound(400, 50);
                    await sleep(speed);
                }
            }

            isAnimating = false;
        }

    async function bfsTraversal() {
        const queue = [];
        const startNode = nodes[0]; // Start from first node

        startNode.visited = true;
        queue.push(startNode);
        visitedNodes.push(startNode.id);

        const speed = 101 - parseInt(document.getElementById('graphSpeedSlider').value);

        while (queue.length > 0 && isAnimating) {
            const current = queue.shift();

            // Highlight current node
            current.visited = true;
            drawGraph();
            playSound(400, 50);
            await sleep(speed);

            // Get all neighbors
            const neighbors = [];
            for (const edge of edges) {
                if (edge.source === current.id && !nodes[edge.target].visited) {
                    neighbors.push(nodes[edge.target]);
                } else if (edge.target === current.id && !nodes[edge.source].visited) {
                    neighbors.push(nodes[edge.source]);
                }
            }

            // Add neighbors to queue
            for (const neighbor of neighbors) {
                neighbor.visited = true;
                queue.push(neighbor);
                visitedNodes.push(neighbor.id);
            }
        }

        isAnimating = false;
    }

    async function dfsTraversal() {
        const stack = [];
        const startNode = nodes[0]; // Start from first node

        startNode.visited = true;
        stack.push(startNode);
        visitedNodes.push(startNode.id);

        const speed = 101 - parseInt(document.getElementById('graphSpeedSlider').value);

        while (stack.length > 0 && isAnimating) {
            const current = stack.pop();

            // Highlight current node
            current.visited = true;
            drawGraph();
            playSound(400, 50);
            await sleep(speed);

            // Get all neighbors
            const neighbors = [];
            for (const edge of edges) {
                if (edge.source === current.id && !nodes[edge.target].visited) {
                    neighbors.push(nodes[edge.target]);
                } else if (edge.target === current.id && !nodes[edge.source].visited) {
                    neighbors.push(nodes[edge.source]);
                }
            }

            // Add neighbors to stack in reverse order for proper DFS
            for (let i = neighbors.length - 1; i >= 0; i--) {
                neighbors[i].visited = true;
                stack.push(neighbors[i]);
                visitedNodes.push(neighbors[i].id);
            }
        }

        isAnimating = false;
    }

    // ===== BINARY TREE ALGORITHMS =====

    // Tree node class
    class TreeNode {
        constructor(value) {
            this.value = value;
            this.left = null;
            this.right = null;
            this.x = 0;
            this.y = 0;
            this.highlighted = false;
        }
    }

    function generateRandomTree() {
        clearTree();
        const values = [];
        const valueCount = Math.floor(Math.random() * 15) + 10; // 10-24 nodes

        for (let i = 0; i < valueCount; i++) {
            values.push(Math.floor(Math.random() * 100) + 1);
        }

        for (const value of values) {
            insertTreeNode(value);
        }

        updateTreeLayout();
        drawTree();
    }

    function insertTreeNode(value) {
        if (treeRoot === null) {
            treeRoot = new TreeNode(value);
            return;
        }

        let current = treeRoot;
        while (true) {
            if (value < current.value) {
                if (current.left === null) {
                    current.left = new TreeNode(value);
                    return;
                }
                current = current.left;
            } else {
                if (current.right === null) {
                    current.right = new TreeNode(value);
                    return;
                }
                current = current.right;
            }
        }
    }

    function clearTree() {
        treeRoot = null;
        drawTree();
    }

    function updateTreeLayout() {
        // Simple tree layout algorithm
        // In a real implementation, you'd use a more sophisticated approach
        if (!treeRoot) return;

        const queue = [{node: treeRoot, level: 0, pos: 0.5}];
        let maxLevel = 0;

        while (queue.length > 0) {
            const {node, level, pos} = queue.shift();

            node.x = pos * treeCanvas.width;
            node.y = (level + 1) * 80;

            maxLevel = Math.max(maxLevel, level);

            if (node.left) {
                queue.push({node: node.left, level: level + 1, pos: pos - 0.5 / Math.pow(2, level + 1)});
            }
            if (node.right) {
                queue.push({node: node.right, level: level + 1, pos: pos + 0.5 / Math.pow(2, level + 1)});
            }
        }

        // Adjust y positions based on max level
        const yScale = treeCanvas.height / (maxLevel + 2);
        const adjustY = (node, level) => {
            if (!node) return;
            node.y = (level + 1) * yScale;
            adjustY(node.left, level + 1);
            adjustY(node.right, level + 1);
        };

        adjustY(treeRoot, 0);
    }

    function drawTree() {
        treeCtx.clearRect(0, 0, treeCanvas.width, treeCanvas.height);

        if (!treeRoot) return;

        // Draw edges first
        treeCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        treeCtx.lineWidth = 2;

        const drawEdges = (node) => {
            if (!node) return;

            if (node.left) {
                treeCtx.beginPath();
                treeCtx.moveTo(node.x, node.y);
                treeCtx.lineTo(node.left.x, node.left.y);
                treeCtx.stroke();
                drawEdges(node.left);
            }

            if (node.right) {
                treeCtx.beginPath();
                treeCtx.moveTo(node.x, node.y);
                treeCtx.lineTo(node.right.x, node.right.y);
                treeCtx.stroke();
                drawEdges(node.right);
            }
        };

        drawEdges(treeRoot);

        // Draw nodes
        const drawNodes = (node) => {
            if (!node) return;

            treeCtx.beginPath();
            treeCtx.arc(node.x, node.y, 20, 0, Math.PI * 2);

            if (node.highlighted) {
                treeCtx.fillStyle = '#ffd93d';
            } else {
                treeCtx.fillStyle = '#4ecdc4';
            }

            treeCtx.fill();
            treeCtx.strokeStyle = 'white';
            treeCtx.lineWidth = 2;
            treeCtx.stroke();

            // Draw value
            treeCtx.fillStyle = 'white';
            treeCtx.font = 'bold 16px Arial';
            treeCtx.textAlign = 'center';
            treeCtx.textBaseline = 'middle';
            treeCtx.fillText(node.value.toString(), node.x, node.y);

            drawNodes(node.left);
            drawNodes(node.right);
        };

        drawNodes(treeRoot);
    }

    function executeTreeOperation() {
            const operation = document.getElementById('treeAlgorithm').value;
            const value = parseInt(document.getElementById('nodeValue').value);

            if (operation !== 'inorder' && operation !== 'preorder' &&
                operation !== 'postorder' && operation !== 'levelorder' && isNaN(value)) {
                alert("Please enter a valid number");
                return;
            }

            switch (operation) {
                case 'insert':
                    insertTreeNode(value);
                    updateTreeLayout();
                    drawTree();
                    break;
                case 'search':
                    searchTreeNode(value);
                    break;
                case 'delete':
                    deleteTreeNode(value);
                    break;
                case 'inorder':
                    inorderTraversal();
                    break;
                case 'preorder':
                    preorderTraversal();
                    break;
                case 'postorder':
                    postorderTraversal();
                    break;
                case 'levelorder':
                    levelorderTraversal();
                    break;
            }
        }

    function deleteTreeNode(value) {
            treeRoot = deleteNode(treeRoot, value);
            updateTreeLayout();
            drawTree();
        }

        function deleteNode(root, value) {
            if (root === null) return null;

            if (value < root.value) {
                root.left = deleteNode(root.left, value);
            } else if (value > root.value) {
                root.right = deleteNode(root.right, value);
            } else {
                // Node to be deleted found

                // Case 1: No child or one child
                if (root.left === null) {
                    return root.right;
                } else if (root.right === null) {
                    return root.left;
                }

                // Case 2: Two children
                // Find inorder successor (smallest in right subtree)
                root.value = minValue(root.right);

                // Delete the inorder successor
                root.right = deleteNode(root.right, root.value);
            }

            return root;
        }

        function minValue(node) {
            let current = node;
            while (current.left !== null) {
                current = current.left;
            }
            return current.value;
        }

        async function inorderTraversal() {
            await traverseTree('inorder');
        }

        async function preorderTraversal() {
            await traverseTree('preorder');
        }

        async function postorderTraversal() {
            await traverseTree('postorder');
        }

        async function levelorderTraversal() {
            await traverseTree('levelorder');
        }

        async function traverseTree(order) {
            if (!treeRoot) return;

            resetTreeHighlights();
            const speed = 101 - parseInt(document.getElementById('treeSpeedSlider').value);

            switch (order) {
                case 'inorder':
                    await inorder(treeRoot, speed);
                    break;
                case 'preorder':
                    await preorder(treeRoot, speed);
                    break;
                case 'postorder':
                    await postorder(treeRoot, speed);
                    break;
                case 'levelorder':
                    await levelorder(treeRoot, speed);
                    break;
            }
        }

        async function inorder(node, speed) {
            if (!node || !isAnimating) return;

            await inorder(node.left, speed);

            node.highlighted = true;
            drawTree();
            playSound(400, 50);
            await sleep(speed);

            await inorder(node.right, speed);
        }

        async function preorder(node, speed) {
            if (!node || !isAnimating) return;

            node.highlighted = true;
            drawTree();
            playSound(400, 50);
            await sleep(speed);

            await preorder(node.left, speed);
            await preorder(node.right, speed);
        }

        async function postorder(node, speed) {
            if (!node || !isAnimating) return;

            await postorder(node.left, speed);
            await postorder(node.right, speed);

            node.highlighted = true;
            drawTree();
            playSound(400, 50);
            await sleep(speed);
        }

        async function levelorder(node, speed) {
            if (!node) return;

            const queue = [node];

            while (queue.length > 0 && isAnimating) {
                const current = queue.shift();

                current.highlighted = true;
                drawTree();
                playSound(400, 50);
                await sleep(speed);

                if (current.left) queue.push(current.left);
                if (current.right) queue.push(current.right);
            }
        }

        function resetTreeHighlights() {
            const resetNode = (node) => {
                if (!node) return;
                node.highlighted = false;
                resetNode(node.left);
                resetNode(node.right);
            };
            resetNode(treeRoot);
        }

    async function searchTreeNode(value) {
        if (!treeRoot) return;

        let current = treeRoot;
        const speed = 101 - parseInt(document.getElementById('treeSpeedSlider').value);

        while (current && isAnimating) {
            current.highlighted = true;
            drawTree();
            playSound(400, 50);
            await sleep(speed);

            if (value === current.value) {
                // Found
                playSound(600, 100);
                return;
            } else if (value < current.value) {
                current.highlighted = false;
                current = current.left;
            } else {
                current.highlighted = false;
                current = current.right;
            }
        }

        // Not found
        playSound(200, 100);
    }

    // Initialize the application
    document.addEventListener('DOMContentLoaded', function() {
            generateArray();
            setupSliders();
            initializeGrid();
            generateGraph();
            updateSortingInfo();
        });
</script>
</body>
</html>
